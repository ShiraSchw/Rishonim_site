<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <title>בחירת קטגוריה והצגת ראשונים</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <h1>בחר קטגוריה</h1>

  <div id="selectors-container"></div>

  <div id="rishon-list"></div>

  <script>
    const categoryTree = {{ category_tree | tojson }};
    const data = {{ rishonim | tojson }};

    const selectorsContainer = document.getElementById('selectors-container');
    const rishonList = document.getElementById('rishon-list');

    // מאחסן את המסלול שנבחר - שמות הקטגוריות שנבחרו בשכבות
    let selectedPath = [];

    // פונקציה לבניית select חדש עם אפשרויות
    function createSelect(options, level) {
      const select = document.createElement('select');
      select.dataset.level = level;
      select.innerHTML = '<option value="">בחר...</option>';

      for (const key in options) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = key;
        select.appendChild(option);
      }

      select.addEventListener('change', onCategoryChange);
      return select;
    }

    // טיפול בבחירת קטגוריה ברמה מסוימת
    function onCategoryChange(event) {
      const select = event.target;
      const level = parseInt(select.dataset.level);

      // מעדכנים את המסלול לפי הבחירה - חותכים כל בחירה בשכבות גבוהות יותר
      selectedPath = selectedPath.slice(0, level);
      if (select.value) {
        selectedPath[level] = select.value;
      } else {
        // אם בחרו "בחר..." - מסירים בחירה ברמה הזו
        selectedPath = selectedPath.slice(0, level);
      }

      // מוחקים selectים מתחת לרמה הנוכחית
      while (selectorsContainer.children.length > level + 1) {
        selectorsContainer.removeChild(selectorsContainer.lastChild);
      }

      // מוצאים את העץ בקטגוריה שנבחרה כדי לבדוק אם יש תתי קטגוריות
      let node = categoryTree;
      for (const p of selectedPath) {
        if (!node) break;
        node = node[p];
      }

      // אם יש תתי קטגוריות והם לא מערך (כלומר יש תתי קטגוריות ולא "רשימת טקסטים")
      if (node && typeof node === 'object' && !Array.isArray(node)) {
        // יוצרים select חדש לתתי הקטגוריות
        const newSelect = createSelect(node, level + 1);
        selectorsContainer.appendChild(newSelect);
        rishonList.innerHTML = '';  // מנקים את הרשימה כי בחרנו עוד
      } else {
        // הגענו לקטגוריה סופית, מוצאים ומציגים את הראשונים התואמים
        showRishonByCategory(selectedPath);
      }
    }

    // פונקציה שמוצאת את הראשונים לפי מסלול קטגוריות
    function showRishonByCategory(categoryPath) {
      // נניח ש"הסיווג" (category) ב־data הוא מחרוזת עם המקטעים מופרדים ב־" > " (אפשר לשנות לפי איך שמירת)
      // לכן נבדוק אם path של הספר מתחיל בדיוק כמו categoryPath.

      // קודם מייצרים מחרוזת מופרדת ב־" > "
      const categoryPathStr = categoryPath.join(' > ');

      // מסננים את הנתונים שמתחילים בקטגוריה הזו
      const filtered = data.filter(item => {
        // נניח ששם השדה הוא "סיווג הספר" ומכיל מחרוזת עם המסלול
        return item['סיווג הספר'].startsWith(categoryPathStr);
      });

      if (filtered.length === 0) {
        rishonList.innerHTML = '<p>לא נמצאו ראשונים לקטגוריה הזו.</p>';
        return;
      }

      let html = '<h2>ראשונים לקטגוריה: ' + categoryPathStr + '</h2><ul>';
      for (const rishon of filtered) {
        html += `<li><strong>${rishon['שם הספר']}</strong> - ${rishon['שם הסופר']} (${rishon['כינוי הסופר']})<br>שיוך: ${rishon['שיוך']}, היכן פורסם: ${rishon['היכן פורסם']}</li>`;
      }
      html += '</ul>';
      rishonList.innerHTML = html;
    }

    // אתחול - יוצרים select ראשון עם הקטגוריות הראשיות
    const firstSelect = createSelect(categoryTree, 0);
    selectorsContainer.appendChild(firstSelect);

  </script>
</body>
</html>
